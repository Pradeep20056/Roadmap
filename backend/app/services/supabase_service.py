from supabase import create_client, Client
from app.core.config import settings
from app.models.user import UserCreate
from app.core.security import get_password_hash
from pydantic import EmailStr
import uuid

class SupabaseService:
    def __init__(self):
        self.client: Client = create_client(settings.SUPABASE_URL, settings.SUPABASE_KEY)

    # --- Auth / User Methods --- (Assuming we manage users in a custom 'users' table for this prompt's requirement, 
    # though Supabase has built-in auth. The prompt specified a 'users' table with password_hash, implying custom auth).
    
    def get_user_by_email(self, email: EmailStr):
        response = self.client.table("users").select("*").eq("email", email).execute()
        if response.data:
            return response.data[0]
        return None

    def create_user(self, user: UserCreate):
        hashed_pw = get_password_hash(user.password)
        # ID is usually auto-generated by DB if UUID/Serial, or we can generate it here. 
        # Let's let Supabase/Postgres handle ID generation if configured, or generate if needed.
        # Assuming the table expects an ID or generates it. Let's try inserting without ID first.
        # If the prompt explicitly asked for ID (uuid) in table def, we might need to generic one if DB doesn't default.
        # Let's generate one to be safe if it's not SERIAL.
        new_user = {
            "id": str(uuid.uuid4()),
            "email": user.email,
            "password_hash": hashed_pw,
            "created_at": "now()"
        }
        response = self.client.table("users").insert(new_user).execute()
        return response.data[0] if response.data else None

    # --- Roadmap Methods ---

    def create_roadmap(self, user_id: str, goal: str, duration: int, roadmap_json: dict):
        new_roadmap = {
            "id": str(uuid.uuid4()),
            "user_id": user_id,
            "goal": goal,
            "duration_weeks": duration,
            "roadmap_json": roadmap_json,
            "created_at": "now()"
        }
        response = self.client.table("roadmaps").insert(new_roadmap).execute()
        return response.data[0] if response.data else None

    def get_user_roadmaps(self, user_id: str):
        # Order by created_at desc
        response = self.client.table("roadmaps").select("*").eq("user_id", user_id).order("created_at", desc=True).execute()
        return response.data

    def update_roadmap_progress(self, roadmap_id: str, week_number: int, is_completed: bool):
        # 1. Fetch existing roadmap
        response = self.client.table("roadmaps").select("*").eq("id", roadmap_id).execute()
        if not response.data:
            return None
        
        roadmap_data = response.data[0]
        roadmap_json = roadmap_data["roadmap_json"]
        
        # 2. Update the specific week
        weeks = roadmap_json.get("weeks", [])
        updated = False
        for week in weeks:
            if week.get("week") == week_number:
                week["isCompleted"] = is_completed
                updated = True
                break
        
        if not updated:
            return None # Week not found
            
        # 3. Save back to DB
        update_response = self.client.table("roadmaps").update({"roadmap_json": roadmap_json}).eq("id", roadmap_id).execute()
        return update_response.data[0] if update_response.data else None

supabase_service = SupabaseService()
